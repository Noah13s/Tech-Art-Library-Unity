using UnityEngine;
using System.Collections.Generic;
using System.Collections;

public class DroneController : MonoBehaviour
{
    public List<Transform> propellers;  // List of propellers attached to the drone
    public float calibrationThrust = 10f;  // Thrust applied during calibration
    public float flightThrust = 20f;  // Flight thrust
    public float propellerTorque = 10f; // Torque generated by propellers
    public Rigidbody droneRigidbody; // Drone's Rigidbody for physics interactions
    public float desiredHeight = 10f; // Desired hover height in meters
    public float heightTolerance = 0.5f; // How much tolerance from desired height before adjusting thrust
    public float thrustAdjustmentSpeed = 1f; // How fast we adjust the thrust

    // PID Controller parameters
    public float Kp = 1.0f; // Proportional gain
    public float Kd = 0.1f; // Derivative gain
    public float Ki = 0.05f; // Integral gain

    private bool isCalibrating = true; // Flag to start calibration process
    private List<Vector3> propellerPositions = new List<Vector3>(); // Stores propeller positions
    private Gyroscope gyroscope; // Gyroscope for measuring tilt
    private Vector3 centerOfGravity; // The calculated center of gravity of the drone
    private float currentHeight; // Current height of the drone
    private float currentVelocity; // Current vertical velocity (y component)
    private float previousHeightError = 0f; // Previous height error for derivative calculation
    private float integral = 0f; // Integral term for PID
    private float totalThrust; // Total thrust to be applied across all propellers

    void Start()
    {
        gyroscope = Input.gyro;  // Assuming you're using a gyroscope for testing
        gyroscope.enabled = true;

        // Get the drone's Rigidbody
        if (!droneRigidbody)
            droneRigidbody = GetComponent<Rigidbody>();

        // Start the calibration process
        StartCoroutine(CalibrateDrone());
    }

    void Update()
    {
        // Only proceed with flight logic after calibration
        if (!isCalibrating)
        {
            // Get current height from the drone's Y position
            currentHeight = transform.position.y;
            // Get current vertical velocity (Y axis velocity)
            currentVelocity = droneRigidbody.velocity.y;

            // Adjust thrust based on current height and velocity
            AdjustThrustForHover();
        }
    }

    IEnumerator CalibrateDrone()
    {
        // Calibration logic (same as before)
        foreach (var propeller in propellers)
        {
            SetAllPropellersToZeroThrust();
            ApplyThrustToPropeller(propeller, calibrationThrust);
            yield return new WaitForSeconds(2f); // Allow time for drone to stabilize
            Vector3 tilt = gyroscope.rotationRate;
            Debug.Log("Tilt for propeller " + propeller.name + ": " + tilt);
            propellerPositions.Add(propeller.position);
        }

        // Calculate the center of gravity (CoG)
        CalculateCenterOfGravity();
        isCalibrating = false; // Finish calibration
        Debug.Log("Calibration completed. CoG: " + centerOfGravity);
    }

    void AdjustThrustForHover()
    {
        // Calculate the height error (distance from desired height)
        float heightError = desiredHeight - currentHeight;

        // Calculate the derivative (velocity error) to prevent overshoot
        float velocityError = -currentVelocity;  // We want to reduce vertical velocity (make it zero)

        // Calculate the integral term for more stable control over time (anti-windup)
        integral += heightError * Time.deltaTime;

        // PID Controller logic for height control
        float heightControl = Kp * heightError + Kd * velocityError + Ki * integral;

        // Update the total thrust applied to all propellers
        totalThrust = Mathf.Clamp(flightThrust + heightControl, 0f, 100f); // Keep thrust within a range

        // Apply thrust across all propellers to hover
        ApplyThrustToAllPropellers(totalThrust);

        // Store the current height error for the next frame (used in derivative calculation)
        previousHeightError = heightError;
    }

    void ApplyThrustToAllPropellers(float thrust)
    {
        // Apply the calculated thrust equally to all propellers for hovering
        foreach (var propeller in propellers)
        {
            // Apply force to each propeller based on the total thrust
            droneRigidbody.AddForceAtPosition(Vector3.up * (thrust / propellers.Count), propeller.position);

            // Apply torque to simulate the propeller's rotational effect
            droneRigidbody.AddTorque(Vector3.up * propellerTorque);
        }
    }

    void SetAllPropellersToZeroThrust()
    {
        // Zero out the thrust from all propellers during calibration
        foreach (var propeller in propellers)
        {
            // For now, we just simulate zero thrust by doing nothing
        }
    }

    void ApplyThrustToPropeller(Transform propeller, float thrust)
    {
        // Apply thrust to a specific propeller position
        droneRigidbody.AddForceAtPosition(Vector3.up * thrust, propeller.position);
    }

    void CalculateCenterOfGravity()
    {
        // Simple center of gravity calculation based on propeller positions
        Vector3 weightedSum = Vector3.zero;
        float totalWeight = 0f;

        foreach (var position in propellerPositions)
        {
            // For simplicity, assume all propellers have equal weight
            weightedSum += position;
            totalWeight++;
        }

        // Average the positions of all propellers to get the center of gravity
        centerOfGravity = weightedSum / totalWeight;
    }
}
